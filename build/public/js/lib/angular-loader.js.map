{"version":3,"sources":["../../../../../../public/js/lib/angular-loader.js"],"names":[],"mappings":"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","file":"angular-loader.js","sourcesContent":["/**\r\n * @license AngularJS v1.3.13\r\n * (c) 2010-2014 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n\r\n(function() {'use strict';\r\n\r\n/**\r\n * @description\r\n *\r\n * This object provides a utility for producing rich Error messages within\r\n * Angular. It can be called as follows:\r\n *\r\n * var exampleMinErr = minErr('example');\r\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\r\n *\r\n * The above creates an instance of minErr in the example namespace. The\r\n * resulting error will have a namespaced error code of example.one.  The\r\n * resulting error will replace {0} with the value of foo, and {1} with the\r\n * value of bar. The object is not restricted in the number of arguments it can\r\n * take.\r\n *\r\n * If fewer arguments are specified than necessary for interpolation, the extra\r\n * interpolation markers will be preserved in the final string.\r\n *\r\n * Since data will be parsed statically during a build step, some restrictions\r\n * are applied with respect to how minErr instances are created and called.\r\n * Instances should have names of the form namespaceMinErr for a minErr created\r\n * using minErr('namespace') . Error codes, namespaces and template strings\r\n * should all be static strings, not variables or general expressions.\r\n *\r\n * @param {string} module The namespace to use for the new minErr instance.\r\n * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning\r\n *   error from returned function, for cases when a particular type of error is useful.\r\n * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance\r\n */\r\n\r\nfunction minErr(module, ErrorConstructor) {\r\n  ErrorConstructor = ErrorConstructor || Error;\r\n  return function() {\r\n    var code = arguments[0],\r\n      prefix = '[' + (module ? module + ':' : '') + code + '] ',\r\n      template = arguments[1],\r\n      templateArgs = arguments,\r\n\r\n      message, i;\r\n\r\n    message = prefix + template.replace(/\\{\\d+\\}/g, function(match) {\r\n      var index = +match.slice(1, -1), arg;\r\n\r\n      if (index + 2 < templateArgs.length) {\r\n        return toDebugString(templateArgs[index + 2]);\r\n      }\r\n      return match;\r\n    });\r\n\r\n    message = message + '\\nhttp://errors.angularjs.org/1.3.13/' +\r\n      (module ? module + '/' : '') + code;\r\n    for (i = 2; i < arguments.length; i++) {\r\n      message = message + (i == 2 ? '?' : '&') + 'p' + (i - 2) + '=' +\r\n        encodeURIComponent(toDebugString(arguments[i]));\r\n    }\r\n    return new ErrorConstructor(message);\r\n  };\r\n}\r\n\r\n/**\r\n * @ngdoc type\r\n * @name angular.Module\r\n * @module ng\r\n * @description\r\n *\r\n * Interface for configuring angular {@link angular.module modules}.\r\n */\r\n\r\nfunction setupModuleLoader(window) {\r\n\r\n  var $injectorMinErr = minErr('$injector');\r\n  var ngMinErr = minErr('ng');\r\n\r\n  function ensure(obj, name, factory) {\r\n    return obj[name] || (obj[name] = factory());\r\n  }\r\n\r\n  var angular = ensure(window, 'angular', Object);\r\n\r\n  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap\r\n  angular.$$minErr = angular.$$minErr || minErr;\r\n\r\n  return ensure(angular, 'module', function() {\r\n    /** @type {Object.<string, angular.Module>} */\r\n    var modules = {};\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name angular.module\r\n     * @module ng\r\n     * @description\r\n     *\r\n     * The `angular.module` is a global place for creating, registering and retrieving Angular\r\n     * modules.\r\n     * All modules (angular core or 3rd party) that should be available to an application must be\r\n     * registered using this mechanism.\r\n     *\r\n     * When passed two or more arguments, a new module is created.  If passed only one argument, an\r\n     * existing module (the name passed as the first argument to `module`) is retrieved.\r\n     *\r\n     *\r\n     * # Module\r\n     *\r\n     * A module is a collection of services, directives, controllers, filters, and configuration information.\r\n     * `angular.module` is used to configure the {@link auto.$injector $injector}.\r\n     *\r\n     * ```js\r\n     * // Create a new module\r\n     * var myModule = angular.module('myModule', []);\r\n     *\r\n     * // register a new service\r\n     * myModule.value('appName', 'MyCoolApp');\r\n     *\r\n     * // configure existing services inside initialization blocks.\r\n     * myModule.config(['$locationProvider', function($locationProvider) {\r\n     *   // Configure existing providers\r\n     *   $locationProvider.hashPrefix('!');\r\n     * }]);\r\n     * ```\r\n     *\r\n     * Then you can create an injector and load your modules like this:\r\n     *\r\n     * ```js\r\n     * var injector = angular.injector(['ng', 'myModule'])\r\n     * ```\r\n     *\r\n     * However it's more likely that you'll just use\r\n     * {@link ng.directive:ngApp ngApp} or\r\n     * {@link angular.bootstrap} to simplify this process for you.\r\n     *\r\n     * @param {!string} name The name of the module to create or retrieve.\r\n     * @param {!Array.<string>=} requires If specified then new module is being created. If\r\n     *        unspecified then the module is being retrieved for further configuration.\r\n     * @param {Function=} configFn Optional configuration function for the module. Same as\r\n     *        {@link angular.Module#config Module#config()}.\r\n     * @returns {module} new module with the {@link angular.Module} api.\r\n     */\r\n    return function module(name, requires, configFn) {\r\n      var assertNotHasOwnProperty = function(name, context) {\r\n        if (name === 'hasOwnProperty') {\r\n          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);\r\n        }\r\n      };\r\n\r\n      assertNotHasOwnProperty(name, 'module');\r\n      if (requires && modules.hasOwnProperty(name)) {\r\n        modules[name] = null;\r\n      }\r\n      return ensure(modules, name, function() {\r\n        if (!requires) {\r\n          throw $injectorMinErr('nomod', \"Module '{0}' is not available! You either misspelled \" +\r\n             \"the module name or forgot to load it. If registering a module ensure that you \" +\r\n             \"specify the dependencies as the second argument.\", name);\r\n        }\r\n\r\n        /** @type {!Array.<Array.<*>>} */\r\n        var invokeQueue = [];\r\n\r\n        /** @type {!Array.<Function>} */\r\n        var configBlocks = [];\r\n\r\n        /** @type {!Array.<Function>} */\r\n        var runBlocks = [];\r\n\r\n        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);\r\n\r\n        /** @type {angular.Module} */\r\n        var moduleInstance = {\r\n          // Private state\r\n          _invokeQueue: invokeQueue,\r\n          _configBlocks: configBlocks,\r\n          _runBlocks: runBlocks,\r\n\r\n          /**\r\n           * @ngdoc property\r\n           * @name angular.Module#requires\r\n           * @module ng\r\n           *\r\n           * @description\r\n           * Holds the list of modules which the injector will load before the current module is\r\n           * loaded.\r\n           */\r\n          requires: requires,\r\n\r\n          /**\r\n           * @ngdoc property\r\n           * @name angular.Module#name\r\n           * @module ng\r\n           *\r\n           * @description\r\n           * Name of the module.\r\n           */\r\n          name: name,\r\n\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#provider\r\n           * @module ng\r\n           * @param {string} name service name\r\n           * @param {Function} providerType Construction function for creating new instance of the\r\n           *                                service.\r\n           * @description\r\n           * See {@link auto.$provide#provider $provide.provider()}.\r\n           */\r\n          provider: invokeLater('$provide', 'provider'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#factory\r\n           * @module ng\r\n           * @param {string} name service name\r\n           * @param {Function} providerFunction Function for creating new instance of the service.\r\n           * @description\r\n           * See {@link auto.$provide#factory $provide.factory()}.\r\n           */\r\n          factory: invokeLater('$provide', 'factory'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#service\r\n           * @module ng\r\n           * @param {string} name service name\r\n           * @param {Function} constructor A constructor function that will be instantiated.\r\n           * @description\r\n           * See {@link auto.$provide#service $provide.service()}.\r\n           */\r\n          service: invokeLater('$provide', 'service'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#value\r\n           * @module ng\r\n           * @param {string} name service name\r\n           * @param {*} object Service instance object.\r\n           * @description\r\n           * See {@link auto.$provide#value $provide.value()}.\r\n           */\r\n          value: invokeLater('$provide', 'value'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#constant\r\n           * @module ng\r\n           * @param {string} name constant name\r\n           * @param {*} object Constant value.\r\n           * @description\r\n           * Because the constant are fixed, they get applied before other provide methods.\r\n           * See {@link auto.$provide#constant $provide.constant()}.\r\n           */\r\n          constant: invokeLater('$provide', 'constant', 'unshift'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#animation\r\n           * @module ng\r\n           * @param {string} name animation name\r\n           * @param {Function} animationFactory Factory function for creating new instance of an\r\n           *                                    animation.\r\n           * @description\r\n           *\r\n           * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.\r\n           *\r\n           *\r\n           * Defines an animation hook that can be later used with\r\n           * {@link ngAnimate.$animate $animate} service and directives that use this service.\r\n           *\r\n           * ```js\r\n           * module.animation('.animation-name', function($inject1, $inject2) {\r\n           *   return {\r\n           *     eventName : function(element, done) {\r\n           *       //code to run the animation\r\n           *       //once complete, then run done()\r\n           *       return function cancellationFunction(element) {\r\n           *         //code to cancel the animation\r\n           *       }\r\n           *     }\r\n           *   }\r\n           * })\r\n           * ```\r\n           *\r\n           * See {@link ng.$animateProvider#register $animateProvider.register()} and\r\n           * {@link ngAnimate ngAnimate module} for more information.\r\n           */\r\n          animation: invokeLater('$animateProvider', 'register'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#filter\r\n           * @module ng\r\n           * @param {string} name Filter name.\r\n           * @param {Function} filterFactory Factory function for creating new instance of filter.\r\n           * @description\r\n           * See {@link ng.$filterProvider#register $filterProvider.register()}.\r\n           */\r\n          filter: invokeLater('$filterProvider', 'register'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#controller\r\n           * @module ng\r\n           * @param {string|Object} name Controller name, or an object map of controllers where the\r\n           *    keys are the names and the values are the constructors.\r\n           * @param {Function} constructor Controller constructor function.\r\n           * @description\r\n           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.\r\n           */\r\n          controller: invokeLater('$controllerProvider', 'register'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#directive\r\n           * @module ng\r\n           * @param {string|Object} name Directive name, or an object map of directives where the\r\n           *    keys are the names and the values are the factories.\r\n           * @param {Function} directiveFactory Factory function for creating new instance of\r\n           * directives.\r\n           * @description\r\n           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.\r\n           */\r\n          directive: invokeLater('$compileProvider', 'directive'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#config\r\n           * @module ng\r\n           * @param {Function} configFn Execute this function on module load. Useful for service\r\n           *    configuration.\r\n           * @description\r\n           * Use this method to register work which needs to be performed on module loading.\r\n           * For more about how to configure services, see\r\n           * {@link providers#provider-recipe Provider Recipe}.\r\n           */\r\n          config: config,\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#run\r\n           * @module ng\r\n           * @param {Function} initializationFn Execute this function after injector creation.\r\n           *    Useful for application initialization.\r\n           * @description\r\n           * Use this method to register work which should be performed when the injector is done\r\n           * loading all modules.\r\n           */\r\n          run: function(block) {\r\n            runBlocks.push(block);\r\n            return this;\r\n          }\r\n        };\r\n\r\n        if (configFn) {\r\n          config(configFn);\r\n        }\r\n\r\n        return moduleInstance;\r\n\r\n        /**\r\n         * @param {string} provider\r\n         * @param {string} method\r\n         * @param {String=} insertMethod\r\n         * @returns {angular.Module}\r\n         */\r\n        function invokeLater(provider, method, insertMethod, queue) {\r\n          if (!queue) queue = invokeQueue;\r\n          return function() {\r\n            queue[insertMethod || 'push']([provider, method, arguments]);\r\n            return moduleInstance;\r\n          };\r\n        }\r\n      });\r\n    };\r\n  });\r\n\r\n}\r\n\r\nsetupModuleLoader(window);\r\n})(window);\r\n\r\n/**\r\n * Closure compiler type information\r\n *\r\n * @typedef { {\r\n *   requires: !Array.<string>,\r\n *   invokeQueue: !Array.<Array.<*>>,\r\n *\r\n *   service: function(string, Function):angular.Module,\r\n *   factory: function(string, Function):angular.Module,\r\n *   value: function(string, *):angular.Module,\r\n *\r\n *   filter: function(string, Function):angular.Module,\r\n *\r\n *   init: function(Function):angular.Module\r\n * } }\r\n */\r\nangular.Module;\r\n\r\n"]}